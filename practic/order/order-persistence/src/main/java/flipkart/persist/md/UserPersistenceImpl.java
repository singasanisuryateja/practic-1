/*
 * mvn generated by tentackle-project-archetype.
 */

package flipkart.persist.md;

import flipkart.pdo.md.User;
import flipkart.pdo.md.User2Group;
import flipkart.pdo.md.UserGroup;
import flipkart.pdo.md.persist.UserPersistence;
import flipkart.persist.PersistenceBundle;
import flipkart.persist.md.rmi.UserRemoteDelegate;

import org.tentackle.common.RemoteMethod;
import org.tentackle.dbms.DbObjectClassVariables;
import org.tentackle.dbms.PreparedStatementWrapper;
import org.tentackle.dbms.ResultSetWrapper;
import org.tentackle.dbms.StatementId;
import org.tentackle.misc.IdentifiableMap;
import org.tentackle.misc.TrackedArrayList;
import org.tentackle.misc.TrackedList;
import org.tentackle.misc.TrackedListListener;
import org.tentackle.pdo.DomainContext;
import org.tentackle.pdo.Pdo;
import org.tentackle.pdo.PdoCache;
import org.tentackle.pdo.PersistentDomainObject;
import org.tentackle.pdo.PersistentObjectService;
import org.tentackle.persist.PersistentObjectClassVariables;
import org.tentackle.session.PersistenceException;
import org.tentackle.session.Session;
import org.tentackle.sql.Backend;
import org.tentackle.sql.JoinType;
import org.tentackle.validate.ValidationResult;
import org.tentackle.validate.ValidationScope;
import org.tentackle.validate.ValidationUtilities;

import java.rmi.RemoteException;
import java.text.MessageFormat;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;

/**
 * Persistence implementation for User.
 */
@PersistentObjectService(User.class)
public class UserPersistenceImpl extends OrgUnitPersistenceImpl<User, UserPersistenceImpl> implements UserPersistence {

  /** serial version UID. */
  private static final long serialVersionUID = -1;

  // @wurblet classVariables ClassVariables

  //<editor-fold defaultstate="collapsed" desc="code 'classVariables' generated by wurblet ClassVariables">//GEN-BEGIN:classVariables

  /** Variables common to all instances of UserPersistenceImpl. */
  @SuppressWarnings({"unchecked", "FieldNameHidesFieldInSuperclass"})
  public static final PersistentObjectClassVariables<User, UserPersistenceImpl> CLASSVARIABLES =
            PersistentObjectClassVariables.create(
                    User.class,
                    UserPersistenceImpl.class,
                    "ur",
                    OrgUnitPersistenceImpl.CLASSVARIABLES,
                    null);

  @Override
  public PersistentObjectClassVariables<User, UserPersistenceImpl> getClassVariables() {
    return CLASSVARIABLES;
  }

  //</editor-fold>//GEN-END:classVariables


  // @wurblet columnNames ColumnNames

  //<editor-fold defaultstate="collapsed" desc="code 'columnNames' generated by wurblet ColumnNames">//GEN-BEGIN:columnNames


  /** database column name for 'password'. */
  public static final String CN_PASSWORD = "password";

  /** database column name for 'loginAllowed'. */
  public static final String CN_LOGINALLOWED = "login_allowed";

  /** database column name for 'passwordChangeable'. */
  public static final String CN_PASSWORDCHANGEABLE = "passwd_chgbl";

  /** database column name for 'changingPreferencesAllowed'. */
  public static final String CN_CHANGINGPREFERENCESALLOWED = "prefs_chgbl";

  /** database column name for 'systemPreferencesOnly'. */
  public static final String CN_SYSTEMPREFERENCESONLY = "prefs_system";

  //</editor-fold>//GEN-END:columnNames


  // @wurblet declare Declare

  //<editor-fold defaultstate="collapsed" desc="code 'declare' generated by wurblet Declare">//GEN-BEGIN:declare


  /** true if login is allowed. */
  private boolean loginAllowed;

  /** user allowed to change its own password?. */
  private boolean passwordChangeable;

  /** user allowed to maintain its own preferences?. */
  private boolean changingPreferencesAllowed;

  /** user restricted to system preferences only?. */
  private boolean systemPreferencesOnly;

  //</editor-fold>//GEN-END:declare


  //<editor-fold defaultstate="collapsed" desc="constructors">

  /**
   * Creates a persistent object for a PDO.
   *
   * @param pdo the persistent domain object
   * @param context the domain context
   */
  public UserPersistenceImpl(User pdo, DomainContext context) {
    super(pdo, context);
  }

  /**
   * Creates a persistent object for a PDO.
   *
   * @param pdo the persistent domain object
   * @param session the session
   */
  public UserPersistenceImpl(User pdo, Session session) {
    super(pdo, session);
  }

  /**
   * Creates a persistent object for a PDO.
   *
   * @param pdo the persistent domain object
   */
  public UserPersistenceImpl(User pdo) {
    super(pdo);
  }

  /**
   * Creates a persistent object.
   */
  public UserPersistenceImpl() {
    super();
  }

  //</editor-fold>

  // @wurblet methods MethodsImpl

  //<editor-fold defaultstate="collapsed" desc="code 'methods' generated by wurblet MethodsImpl">//GEN-BEGIN:methods


  @Override
  public UserRemoteDelegate getRemoteDelegate() {
    return (UserRemoteDelegate) super.getRemoteDelegate();
  }

  @Override
  public void getFields(ResultSetWrapper rs) {
    super.getFields(rs);
    if (rs.configureSection(CLASSVARIABLES)) {
      rs.configureColumn(CN_LOGINALLOWED);
      rs.configureColumn(CN_PASSWORDCHANGEABLE);
      rs.configureColumn(CN_CHANGINGPREFERENCESALLOWED);
      rs.configureColumn(CN_SYSTEMPREFERENCESONLY);
    }
    if (rs.getRow() <= 0) {
      throw new PersistenceException(getSession(), "no valid row");
    }
    loginAllowed = rs.getBoolean();
    passwordChangeable = rs.getBoolean();
    changingPreferencesAllowed = rs.getBoolean();
    systemPreferencesOnly = rs.getBoolean();
  }

  /**
   * Sets the values of all User-columns in the given statement.
   *
   * @param st the prepared statement
   * @return the number of columns set
   */
  public int setFieldsUser(PreparedStatementWrapper st) {
    int ndx = 0;
    st.setBoolean(++ndx, loginAllowed);
    st.setBoolean(++ndx, passwordChangeable);
    st.setBoolean(++ndx, changingPreferencesAllowed);
    st.setBoolean(++ndx, systemPreferencesOnly);
    st.setLong(++ndx, getId());
    return ndx;
  }

  /**
   * Creates the SQL code for the User insert statement.
   *
   * @return the SQL code
   */
  public String createInsertSqlUser() {
    return Backend.SQL_INSERT_INTO + CLASSVARIABLES.getTableName() + Backend.SQL_LEFT_PARENTHESIS +
           CN_LOGINALLOWED + Backend.SQL_COMMA +
           CN_PASSWORDCHANGEABLE + Backend.SQL_COMMA +
           CN_CHANGINGPREFERENCESALLOWED + Backend.SQL_COMMA +
           CN_SYSTEMPREFERENCESONLY + Backend.SQL_COMMA +
           CN_ID +
           Backend.SQL_INSERT_VALUES +
           Backend.SQL_PAR_COMMA +
           Backend.SQL_PAR_COMMA +
           Backend.SQL_PAR_COMMA +
           Backend.SQL_PAR_COMMA +
           Backend.SQL_PAR + Backend.SQL_RIGHT_PARENTHESIS;
  }

  /**
   * Creates the SQL code for the User update statement.
   *
   * @return the SQL code
   */
  public String createUpdateSqlUser() {
    return Backend.SQL_UPDATE + CLASSVARIABLES.getTableName() + Backend.SQL_SET +
           CN_LOGINALLOWED + Backend.SQL_EQUAL_PAR_COMMA +
           CN_PASSWORDCHANGEABLE + Backend.SQL_EQUAL_PAR_COMMA +
           CN_CHANGINGPREFERENCESALLOWED + Backend.SQL_EQUAL_PAR_COMMA +
           CN_SYSTEMPREFERENCESONLY + Backend.SQL_EQUAL_PAR +
           Backend.SQL_WHERE + CN_ID + Backend.SQL_EQUAL_PAR;
  }

  /**
   * Creates the SQL code for the User delete statement.
   *
   * @return the sql code
   */
  public String createDeleteSqlUser() {
    return Backend.SQL_DELETE + Backend.SQL_FROM + CLASSVARIABLES.getTableName() +
           Backend.SQL_WHERE + CN_ID + Backend.SQL_EQUAL_PAR;
  }

  @Override
  public StringBuilder createSelectAllInnerSql() {
    StringBuilder sql = new StringBuilder();
    sql.append(OrgUnitPersistenceImpl.CLASSVARIABLES.getColumnName(Backend.SQL_ALLSTAR));
    sql.append(Backend.SQL_COMMA).append(UserPersistenceImpl.CLASSVARIABLES.getColumnName(Backend.SQL_ALLSTAR));
    sql.append(Backend.SQL_FROM);
    sql.append(OrgUnitPersistenceImpl.CLASSVARIABLES.getTableName()).
        append(getBackend().sqlAsBeforeTableAlias()).append(OrgUnitPersistenceImpl.CLASSVARIABLES.getTableAlias());
    sql.append(getBackend().sqlJoin(JoinType.INNER,
               UserPersistenceImpl.CLASSVARIABLES.getTableName(), UserPersistenceImpl.CLASSVARIABLES.getTableAlias(),
               OrgUnitPersistenceImpl.CLASSVARIABLES.getColumnName(CN_ID) + Backend.SQL_EQUAL +
               UserPersistenceImpl.CLASSVARIABLES.getColumnName(CN_ID)));
    sql.append(Backend.SQL_WHEREALL);
    return sql;
  }

  @Override
  public StringBuilder createSelectAllByIdInnerSql() {
    StringBuilder sql = createSelectAllInnerSql();
    sql.append(Backend.SQL_AND).
        append(OrgUnitPersistenceImpl.CLASSVARIABLES.getColumnName(CN_ID)).
        append(Backend.SQL_EQUAL_PAR);
    return sql;
  }

  @Override
  protected void updateImpl(DbObjectClassVariables<UserPersistenceImpl> classVariables,
                            Supplier<String> sqlsupplier) {
    super.updateImpl(classVariables, sqlsupplier);
    PreparedStatementWrapper st = getPreparedStatement(CLASSVARIABLES.updateStatementId, this::createUpdateSqlUser);
    setFieldsUser(st);
    assertThisRowAffected(st.executeUpdate());
  }

  @Override
  protected void insertImpl(DbObjectClassVariables<UserPersistenceImpl> classVariables,
                            Supplier<String> sqlsupplier) {
    super.insertImpl(classVariables, sqlsupplier);
    PreparedStatementWrapper st = getPreparedStatement(CLASSVARIABLES.insertStatementId, this::createInsertSqlUser);
    setFieldsUser(st);
    assertThisRowAffected(st.executeUpdate());
  }

  @Override
  protected void deleteImpl(DbObjectClassVariables<UserPersistenceImpl> classVariables,
                            Supplier<String> sqlsupplier) {
    PreparedStatementWrapper st = getPreparedStatement(CLASSVARIABLES.deleteStatementId, this::createDeleteSqlUser);
    st.setLong(1, getId());
    assertThisRowAffected(st.executeUpdate());
    super.deleteImpl(classVariables, sqlsupplier);
  }

  @Override
  public boolean isLoginAllowed()    {
    return loginAllowed;
  }

  @Override
  public void setLoginAllowed(boolean loginAllowed) {
    assertMutable();
    if (this.loginAllowed != loginAllowed) {
      setModified(true);
    }
    this.loginAllowed = loginAllowed;
  }

  @Override
  public boolean isPasswordChangeable()    {
    return passwordChangeable;
  }

  @Override
  public void setPasswordChangeable(boolean passwordChangeable) {
    assertMutable();
    if (this.passwordChangeable != passwordChangeable) {
      setModified(true);
    }
    this.passwordChangeable = passwordChangeable;
  }

  @Override
  public boolean isChangingPreferencesAllowed()    {
    return changingPreferencesAllowed;
  }

  @Override
  public void setChangingPreferencesAllowed(boolean changingPreferencesAllowed) {
    assertMutable();
    if (this.changingPreferencesAllowed != changingPreferencesAllowed) {
      setModified(true);
    }
    this.changingPreferencesAllowed = changingPreferencesAllowed;
  }

  @Override
  public boolean isSystemPreferencesOnly()    {
    return systemPreferencesOnly;
  }

  @Override
  public void setSystemPreferencesOnly(boolean systemPreferencesOnly) {
    assertMutable();
    if (this.systemPreferencesOnly != systemPreferencesOnly) {
      setModified(true);
    }
    this.systemPreferencesOnly = systemPreferencesOnly;
  }

  /**
   * Copies all attributes from a snapshot back to this object.
   *
   * @param snapshot the snapshot object
   */
  protected void revertAttributesToSnapshot(UserPersistenceImpl snapshot) {
    super.revertAttributesToSnapshot(snapshot);
    loginAllowed = snapshot.loginAllowed;
    passwordChangeable = snapshot.passwordChangeable;
    changingPreferencesAllowed = snapshot.changingPreferencesAllowed;
    systemPreferencesOnly = snapshot.systemPreferencesOnly;
  }

  //</editor-fold>//GEN-END:methods


  // @wurblet relations PdoRelations

  //<editor-fold defaultstate="collapsed" desc="code 'relations' generated by wurblet PdoRelations">//GEN-BEGIN:relations


  // composite list of User2Group nmLinks via User2Group#userId (NmLinks)
  private TrackedList<User2Group> nmLinks;
  private boolean nmLinksLoaded;
  private transient TrackedList<User2Group> nmLinksSnapshot;
  private transient TrackedList<UserGroup> userGroups;

  @Override
  public TrackedList<User2Group> getNmLinks()  {
    if (!nmLinksLoaded) {
      nmLinks = isNew() ? new TrackedArrayList<>(false) : on(User2Group.class).selectByUserId(getId());
      if (isImmutable()) {
        nmLinks.setImmutable(true);
      }
      nmLinksLoaded = true;
      nmLinks.addListener(new TrackedListListener<>() {

        @Override
        public void added(User2Group element) {
          getUserGroups().addIfAbsent(element.getUserGroup());
        }

        @Override
        public void removed(User2Group element) {
          getUserGroups().remove(element.getUserGroup());
        }
      });
    }
    return nmLinks;
  }

  /**
   * Gets nmLinks without performing a select if not loaded.
   *
   * @return nmLinks NmLinks
   */
  public TrackedList<User2Group> getNmLinksBlunt() {
    if (!nmLinksLoaded) {
      nmLinks = new TrackedArrayList<>(false);
      if (isImmutable()) {
        nmLinks.setImmutable(true);
      }
      nmLinksLoaded = true;
    }
    return nmLinks;
  }

  @Override
  public TrackedList<UserGroup> getUserGroups() {
    if (userGroups == null) {
      userGroups = new TrackedArrayList<>() {

        @Override
        public boolean isModified() {
          return getNmLinks().isModified();
        }
      };

      for (User2Group obj: getNmLinks()) {
        userGroups.add(obj.getUserGroup());
      }

      userGroups.addListener(new TrackedListListener<>() {

        @Override
        public void added(UserGroup element) {
          User2Group obj = on(User2Group.class);
          obj.setUserGroup(element);
          getNmLinks().add(obj);
        }

        @Override
        public void removed(UserGroup element) {
          for (Iterator<User2Group> iter = getNmLinks().iterator(); iter.hasNext(); ) {
            User2Group obj = iter.next();
            if (Objects.equals(obj.getUserGroup(), element)) {
              iter.remove();
              break;
            }
          }
        }
      });
    }
    return userGroups;
  }

  @Override
  public boolean isNmLinksLoaded() {
    return nmLinksLoaded;
  }

  @Override
  public void setSession(Session session)  {
    super.setSession(session);
    session.applyTo(nmLinks);
  }

  @Override
  public void setDomainContext(DomainContext context)  {
    super.setDomainContext(context);
    context.applyTo(nmLinks);
  }

  /**
   * Deletes all referencing composite relations that have been removed from the PDO.<br>
   * The database cascades down via referential integrity.
   */
  public void deleteRemovedReferencingRelations() {
    if (nmLinks != null && nmLinks.isSomeRemoved()) {
      delete(nmLinks.getRemovedObjects());
    }
  }

  @Override
  public void saveReferencingRelations(boolean update)  {
    super.saveReferencingRelations(update);
    if (update) {
      deleteRemovedReferencingRelations();
    }
    if (nmLinks != null) {
      getDomainContext().applyTo(nmLinks);
      for (User2Group obj: nmLinks)  {
        obj.setUserId(getId());
      }
      save(nmLinks, true);
    }
  }

  @Override
  public List<ValidationResult> validate(String validationPath, ValidationScope scope) {
    List<ValidationResult> results = super.validate(validationPath, scope);
    if (nmLinks != null) {
      results.addAll(ValidationUtilities.getInstance().validateCollection(
                nmLinks, validationPath + ".nmLinks", scope));
    }
    return results;
  }

  @Override
  public void setImmutable(boolean immutable) {
    super.setImmutable(immutable);
    if (nmLinks != null) {
      nmLinks.setImmutable(immutable);
    }
  }

  @Override
  public boolean isModified()  {
    return super.isModified()
           || isModified(nmLinks)
           ;
  }

  @Override
  public boolean isComposite()  {
    return true;
  }


  @Override
  public IdentifiableMap<? extends PersistentDomainObject<?>> loadComponents(boolean onlyLoaded) {
    IdentifiableMap<PersistentDomainObject<?>> components = new IdentifiableMap<>();
    addComponents(components, onlyLoaded);
    return components;
  }

  @Override
  public int addComponents(IdentifiableMap<PersistentDomainObject<?>> components, boolean onlyLoaded)  {
    int count = 0;
    count += super.addComponents(components, onlyLoaded);
    if (!onlyLoaded || nmLinksLoaded) {
      count += addComponents(components, getNmLinks(), onlyLoaded);
    }
    return count;
  }

  @Override
  public void insertPlainWithComponents()  {
    insertPlain();
    insertPlainWithComponents(getNmLinks());
  }

  @Override
  public void deletePlainWithComponents()  {
    // components are deleted via database referential integrity constraints
    deletePlain();
  }

  @Override
  public void markDeleted() {
    super.markDeleted();
    markDeleted(nmLinks);
  }

  /**
   * Updates the components in snapshot object.<br>
   * The snapshot object is assumed to be a clone of this object.
   *
   * @param snapshot the snapshot
   */
  protected void createComponentsInSnapshot(UserPersistenceImpl snapshot) {
    super.createComponentsInSnapshot(snapshot);
    snapshot.nmLinksSnapshot = TrackedList.createSnapshot(nmLinks);
  }

  /**
   * Reverts all components of this object to a given snapshot.
   *
   * @param snapshot the snapshot object
   */
  protected void revertComponentsToSnapshot(UserPersistenceImpl snapshot) {
    super.revertComponentsToSnapshot(snapshot);
    nmLinks = TrackedList.revertToSnapshot(nmLinks, snapshot.nmLinksSnapshot);
    nmLinksLoaded = snapshot.nmLinksLoaded;
    userGroups = null;
  }

  //</editor-fold>//GEN-END:relations


  // @wurblet cache PdoCache --preload

  //<editor-fold defaultstate="collapsed" desc="code 'cache' generated by wurblet PdoCache">//GEN-BEGIN:cache


  /** the cache. */
  private static PdoCache<User> cache;

  /**
   * Creates the cache singleton if it does not exist.
   *
   * @return the cache singleton
   */
  private static synchronized PdoCache<User> createCache() {
    if (cache == null) {
      cache = Pdo.createPdoCache(User.class, true, true, false);
      Pdo.listen(ev -> cache.expire(ev.getSerial()), User.class);
    }
    return cache;
  }

  @Override
  public PdoCache<User> getCache() {
    return cache == null ? createCache() : cache;
  }

  @Override
  public boolean isCountingModification(char modType) {
    return true;
  }

  @Override
  public boolean isReadAllowed() {
    return true;
  }

  @Override
  public boolean expireCache(long maxSerial) {
    getCache().expire(maxSerial);
    return true;
  }

  @Override
  public User selectCachedOnly(long id) {
    return getCache().select(getDomainContext(), id, false);
  }

  @Override
  public User selectCached(long id) {
    return getCache().select(getDomainContext(), id);
  }

  @Override
  public List<User> selectAllCached() {
    return getCache().selectAll(getDomainContext());
  }

  //</editor-fold>//GEN-END:cache



  /*
   * Implements the handling of passwords. The hash is not part of the PDO and thus
   * not transferred over the wire along with user PDOs.
   * It is recommended to use SSL at least during authentication/login and for User-PDOs in general.
   * This will encrypt the rmi-calls below.
   */

  private static final StatementId SELECT_PASSWORD_STMT = new StatementId();

  @Override
  @RemoteMethod
  public String selectPasswordHash() {
    assertNotNew();

    // @wurblet selectPasswordHash RemoteMethod --this

    //<editor-fold defaultstate="collapsed" desc="code 'selectPasswordHash' generated by wurblet RemoteMethod">//GEN-BEGIN:selectPasswordHash

    if (getSession().isRemote())  {
      try {
        return getRemoteDelegate().selectPasswordHash(me());
      }
      catch (RemoteException e) {
        throw PersistenceException.createFromRemoteException(this, e);
      }
    }

    //</editor-fold>//GEN-END:selectPasswordHash


    assertPasswordAccessible();
    PreparedStatementWrapper st = getPreparedStatement(SELECT_PASSWORD_STMT, () ->
             "SELECT " + CN_PASSWORD + " FROM " + getTableName() + " WHERE " + CN_ID + "=?");
    st.setLong(1, getId());
    try (ResultSetWrapper rs = st.executeQuery()) {
      if (rs.next()) {
        return rs.getString(1);
      }
    }
    return null;
  }

  private static final StatementId UPDATE_PASSWORD_STMT = new StatementId();

  @Override
  @RemoteMethod
  public void updatePasswordHash(String password) {
    assertNotNew();

    // @wurblet updatePasswordHash RemoteMethod --this

    //<editor-fold defaultstate="collapsed" desc="code 'updatePasswordHash' generated by wurblet RemoteMethod">//GEN-BEGIN:updatePasswordHash

    if (getSession().isRemote())  {
      try {
        getRemoteDelegate().updatePasswordHash(password, me());
        return;
      }
      catch (RemoteException e) {
        throw PersistenceException.createFromRemoteException(this, e);
      }
    }

    //</editor-fold>//GEN-END:updatePasswordHash


    assertPasswordAccessible();
    PreparedStatementWrapper st = getPreparedStatement(UPDATE_PASSWORD_STMT, () ->
        "UPDATE " + getTableName() + " SET " +  CN_PASSWORD + "=? WHERE " + CN_ID + "=?");
    st.setString(1, password);
    st.setLong(2, getId());
    assertThisRowAffected(st.executeUpdate());
  }

  /**
   * Checks whether current user is allowed to access the password.
   * To access the password, the current user must match the user the password belongs to
   * or the current user must be admin with edit permission for this user.
   */
  private void assertPasswordAccessible() {
    if (getDomainContext().getSessionInfo().getUserId() != me().getId() && !isEditAllowed()) {
      throw new PersistenceException(me(), MessageFormat.format(PersistenceBundle.getString("you.have.no.permission.to.access.the.password.of.0"), me()));
    }
  }
}
